package logicElements.analyzer;

import java.util.HashMap;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import de.mannheim.wifo2.fesas.logicRepositoryStructure.data.metadata.logic.AbstractLogic;
import de.mannheim.wifo2.fesas.logicRepositoryStructure.data.metadata.logic.LogicType;
import de.mannheim.wifo2.fesas.logicRepositoryStructure.data.metadata.logic.logicInterfaces.IAnalyzerLogic;
import de.mannheim.wifo2.fesas.sasStructure.data.adaptationLogic.information.InformationType;
import de.mannheim.wifo2.fesas.sasStructure.data.adaptationLogic.knowledge.IKnowledgeRecord;
import de.mannheim.wifo2.fesas.sasStructure.data.adaptationLogic.knowledge.KnowledgeRecord;
import dependencies.RulesUtil;
import jdk.nashorn.api.scripting.JSObject;
import logicElements.knowledge.ActionType;
import logicElements.knowledge.AnalyzeTypes;
import logicElements.knowledge.SensorType;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import javax.script.Invocable;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;

/**
 * Description from meta data: 
 * 
 * This file has been generated by the FESAS development tool set.
 * 
 * @author FESAS 
 *
 */
public class Analyzer extends AbstractLogic implements IAnalyzerLogic {

	final static Logger logger = LogManager.getLogger(Analyzer.class);

	public Analyzer() {
		super();	
		supportedInformationTypes.add(InformationType.Monitoring_DEFAULT);
	
		this.informationType = InformationType.Analyzing_DEFAULT;
		type = LogicType.ANALYZER;
		shortName = "Analyzer";
	}

	// do not change anything above this line (except of adding import statements)

	//add variables here
	JsonObject rules;
	ScriptEngine engine;

	@Override
	public void initializeLogic(HashMap<String, String> properties) {
		try {
			rules = RulesUtil.loadFromClasspath("rules.json");
			engine = new ScriptEngineManager().getEngineByName("nashorn");
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Analyzes the data based on the properties defined in resources/rules.json
	 * @param data
	 * @return
	 */
	@Override
	public String callLogic(IKnowledgeRecord data)  {
		if (data instanceof KnowledgeRecord) {
			if (data.getData() instanceof JsonObject) {

				try {
					System.out.println("In Analyzer");
					//Extract mandatory data of the JsonObject
					JsonObject sensor = (JsonObject) data.getData();
					String resourceId = sensor.get("resourceId").getAsString();
					SensorType sensorType = SensorType.byValue(sensor.get("sensorType").getAsString());
					JsonObject sensorData = sensor.getAsJsonObject("data");

					for (JsonElement condition: rules.getAsJsonObject(sensorType.toString()).getAsJsonArray("conditions")){

						JsonObject currentCondition = condition.getAsJsonObject();
						String name = currentCondition.get("name").getAsString();
						String eval = currentCondition.get("eval").getAsString();
						String action = currentCondition.get("action").getAsString();

						if ((boolean) ((JSObject) engine.eval(eval)).call(null,sensorData.get("values").getAsJsonArray().get(0).getAsInt())) {
							this.sendData(new JsonParser().parse("{resourceId: " + resourceId +", action: " + ActionType.byValue(action)+", reason: " + name + "}").getAsJsonObject());
						}

					}
				} catch (Exception e){
					e.printStackTrace();
				}





			}
			return "Not the expected data type! It is: " + data.getData().getClass().getSimpleName();
		}
		return "Not a KnowledgeRecord! It is: " + data.getClass().getSimpleName();
	}
	
	// add further methods if needed

}
